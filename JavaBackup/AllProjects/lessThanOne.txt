
/*
isNegative(
	r0 = N, tenuto costante
	r1,2 = truth pair for the result (r1==1 & r2==0 <-> N < 1  ; r2==1 & r1==0 <-> N >= 1) [inizialmente <1,0>]
	r3 = 0-ancilla -> conterra' il reminder: N%2
	r4 = 0-ancilla -> conterra' la meta' intera: sign(N)* floor(|N|/2) per poi essere ri-trasformata in 0-ancilla
)
*/

// inc r4 ; // 1-ancilla

for r0  {
	swap(r1, r2) ;
	for r1 {
		inc r3 ;
	}
}
// halve(r0, r1, r2, r3)


for r2{ // DISPARI
	// r1 == 0
	for r0 { inc r4 }
	for r3 { dec r4 dec r4 }
	// r4 == 1 ... non sign(N)
}

for r1 { // PARI
	inc r4 ; // ora e' una 1-ancilla


	inc r0 // rendiamolo dispari










	// riazzeriamo r3
	for r0 {
		swap(r4, r2)
		for r4 { dec r3 }
	}

	inc r0 // rendiamo r0 dispari
	for r0 {
		swap(r4, r2)
		for r4 { inc r3 }
	}
	swap(r4, r2) // essendo r0 dispari

	dec r4 // ritorna 0-ancilla

	//si ha, quindi:

	// r2 == 0
	// r3 == ... N==0 -> 0 ;; N==2 -> 1 ;; N==-2 -> -1 ;; N==4 -> 2 ;; N==-4 -> -2 .. halve, as expected
	// r4 == 0

	dec r0
}












dec r4 ; // back to 0-ancilla
















for r1 { // PARI
	dec r0

	swap(r2, r4)

	inc r0
}

for r0  {
	swap(r1, r2) ;
	for r1 {
		inc r4 ;
	}
}

//	stato attuale:
//	r0 = N
//	r1 = b_even
//	r2 = b_odd
//	r3 = 0
//	r4 = floor(N/2) [i.e.:  sign(N)* int(|N|/2) - (N>=0? 0 : 1) ]



swap(r1, r2) ;




for r1  { // DISPARI - parte 1

//	stato attuale:
//	r0 = N
//	r1 = 1
//	r2 = 0
//	r3 = 0
//	r4 = sign(N)* floor(|N|/2) - (N>=0 ? 0 : 1) (alias: "la meta' intera")





























	// metto in r3 il reminder
	for r0  {
		inc r3 ;
	}
	// r3 == N
	for r4  {
		dec r3 ; dec r3 ;
	}
	// r3 vale 1 o -1, ergo sign(N)

	// non mi serve piu' la meta' intera
	// sapendo che r2 vale 0, uso r3,2 come truth pair (ma r3 puo' essere negativo)
	for r0  {
		swap(r2, r3) ;
		for r3 {
			for r3 {
				dec r4 ; // se il segno fosse -1, allora sara' "inc", dato che ci sarebbero ben TRE inverse di "dec" (di cui due si annullano), facendo convergere r4 a zero anche se era minore di zero
			}
		}
	}

	swap(r2, r3) ; // perche' r0 e' dispari


//	stato attuale:
//	r0 = N
//	r1 = 1
//	r2 = 0
//	r3 = sign(N)
//	r4 = 0

}



//Osservazione: 2 deve restituire falso esattamente come 1.
//Similarmente, 0 deve restituire vero esattamente come -1.
//Quindi si riduce N di 1 e si procede coi "dispari" come se nulla fosse.

/*
for r2  { // PARI
	// devo riazzerare r4, uso r1,3 come truth-pair per ricalcolare la meta' in r4
	inc r1 ; // vale 1 ora, r3 vale ancora 0
	for r0  {
		swap(r1, r3) ;
		for r1 { dec r4 ; }
	}
	// r4 vale 0 di nuovo ;  il numero di swap eseguiti e' pari -> r1==1 ; r3==0


	dec r0 ; // decremento temporaneo
	for r0  { // ricalcolo della meta'
		swap(r1, r3) ;
		for r1 { inc r4 ; } // ricalcolo della meta'
	}
	// r3 vale 1, essendo r0 ora dispari, ma deve valere N-1 affinche' si usi il codice dei dispari (quello sottostante), fuori da questo ciclo
	dec r3 ; // ora vale 0
	for r0  {
		inc r3 ;
	}
	// ora e' vero che r3==N-1
	dec r1 ; // torna a valere 0, come valeva prima del ciclo su r2
	// inc r0 ; // ripristino di r0 // tolto per mantenerlo dispari, serve sotto

	
//	stato attuale:
//	r0 = N-1 (tornera' N)
//	r1 = 0
//	r2 = 1
//	r3 = N-1 // ed e' dispari
//	r4 = (N-1)/2
	

	for r4  {
		dec r3 ; dec r3 ;
	}
	// r3 vale 1 o -1, ergo sign(N)

	// non mi serve piu' la meta' intera
	// sapendo che r1 vale 0, uso r3,1 come truth pair (ma r3 puo' essere negativo)
	for r0  {
		swap(r1, r3) ;
		for r1 {
			for r1 {
				dec r4 ; // se il segno fosse -1, allora sara' "inc", dato che ci sarebbero ben TRE inverse di "dec" (di cui due si annullano), facendo convergere r4 a zero anche se era minore di zero
			}
		}
	}

	swap(r1, r3) ; // perche' r0 e' dispari
	inc r0 ; // ripristino di r0


//	stato attuale:
//	r0 = N
//	r1 = 0
//	r2 = 1
//	r3 = sign(N-1)
//	r4 = 0

}
*/



/*
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// FINE parte legata alla parita', INIZIO parte "generale" (legata al segno)


// r1,2 deve esere una truth-pair, ma ora contiene la verita' di "N e' dispari?" 
inc r0 ;
for r0 { // se r0 era pari, ora sara' dispari, quindi alla fine del ciclo r1 ed r2 saranno davvero invertiti
	swap(r1, r2) ;
}
dec r0 ;



//	stato attuale:
//	r0 = N
//	r1 = 1
//	r2 = 0
//	r3 = sign(N - |N%2|)
//	r4 = 0



// ora r3 contiene davvero il reminder
// ancora meglio: il valore assoluto di r3 e' la risposta
// ossia: N < 1 <-> r3 < 0
// quindi, se r3 > 0 allora e' necessario uno swap tra r1 ed r2


//Ora si trasla l'intervallo di valori che pu√≤ contenere r3 (da  {-1, 1} a  {0, 2}) per sfruttare la proprieta' del for di NON eseguire il corpo se il registro contiene zero ....
//Salvo quindi in r4 la quantita' di swap(r1, r2) da eseguire
//(sfruttando poi il valore di r2 per azzerare r4, nel caso)

inc r3 ;
for r3 { // se siamo qui, e' perche' r3==2
	swap(r1, r2) ;
	for r1  {
		inc r4 ;
	}
}

for r4  {
	// swap
	dec r1 ; inc r2 ;
	// sappiamo che r3 vale 2, perche' senno' r4 non sarebbe mai valso 1 (grazie al ciclo precedente)
	dec r3 ; dec r3 ; // ora r3 vale 0
}
for r2  { dec r4 ; } // azzeriamo r4

*/