TODO:
aggiunti nel 28/03/2020
-) spostare nel GModality insiemi di azioni come "muovi , danneggia, drop a terra, raccogli, spawna, etc"
	così da gestire LI la generazione di eventi (che ricordo essere opzionale).
-) -> così come c'è la GEventInterface, creare la GObjectsInterface, che può richiedere una GEventInterface per
-) -> eventualmente separare da GModality le varie funzionalità in interfacce come quelle sopra (anche la gestione del tempo per
	i TimedObject) così da permettere più facili composizioni ed eredità in futuro, in giochi/test particolari
-) finire di trasformare un player in una interfaccia 
-) rendere gli equipaggiamenti "dinamici" secondo un JSON (del 24/03):
	[
		{
			name: String,
			ID: Integer, // autogenerated by inventoryID
			type: int, // index di EquipmentTypesTRAr
			abilities: String[] // name identifiers of a EquipItemAbility (sub-interface of AbilityGeneric)
		}
	]




24/03/2020
I pezzi di equipaggiamento potrebbero essere contenuti in un JSON bello grosso a mo' di database:
tipo:
{
nome: string,
type: int, // ordinal di EquipmentTypes
attributesModifiers: []EquipmentsAttributesModifier // potrebbe essere diviso in due array: uno di indici di attributi, l'altro di "ammontare di modifica"
upgrades: []int // id (ordinal) di EquipmentUpgrades, interfaccia per una enumerazione da fare che è una lista di EquipmentsAttributesModifier
specialAbilities: []int // id (ordinal) di un insieme (enum) di EquipAbilities (es: un anello 
}

EquipmentsAttributesModifier è una coppia <indice, valore>, ossia l'indice del' attributo
di eroe/creatura/etc da alterare e l'ammontare di tale alterazione.
(es: se rigenVita avesse indice 7, allora <7, 3> da un bonus di rigenerazione alla vita di 3 al secondo)

interface EquipAbilities .. vedi implementazione





22/03/2020
come scrissi, l'equipaggiamento è complesso e diviso in 9 pezzi + 10 anelli + 3 collane
orecchini	|	testa	|	mantello
mani		|	busto	|	braccia
piedi		|	cintura	|	gambe(pantaloni)
arma primaria	((vuoto))	arma secondaria
originariamente al posto degli orecchini c'erano le spalle .. le incorporo in "braccia", che prima erano "avambracci"
poi una colonna per ciascuna mano, le 3 collane in colonna
aggiungere i braccialetti alle due mani? troppo incasinato, ma ci sta: con le collane si otterrebbe una colonna completa alta 5
magari al posto di "vuoto" metterci un "famiglio"
per ogni mano, se il numero di anelli supera il 2 allora si ha un progressivo malus in agilità, forza, destrezza, precisione
(tienila te una spada facendo presa con migliaia di anelli)
originariamente ciascun dito poteva tenere 2 anelli (aveva 2 slot) e gli anelli erano divisi in "slot singolo" e "doppio slot"
(un po' come le armi a due mani) e la regola di cui sopra si applicava per un numero di slot superiore a 3.
Si potrebbe implementare, con l'accortezza però che gli anelli "singoli" siano più deboli dei "doppi".
In tal caso, per calcolare il malus sopra, gli anelli doppi contano come 1.5 per tutto il dito
(mentre due anelli singoli contano come 1 ciascuno, quindi 2), perchè per essere indossati hanno delle prese ergonomiche.



19/03/2020

La logica ad eventi è avvincente, MA è sconveniente per infliggere danno alle cose che hanno una vita:
- Se si usassero gli eventi, allora bisognerebbe notificare TUTTI di ogni singolo evento di danneggiamento
	E tali oggetti dovrebbero sempre controllare che il "target" del danno non sia sè stesso (o, ancora peggio,
	controllare che sè stessi non sia inclusi nell'insieme di "targets")
- con il "danno diretto", si può da un lato semplificare, dall'altro complicare:
- - si complica perchè risulta difficile prevenire/amplificare/ridurre/redirezionare il danno, mentre con gli
	eventi risulta più facile modificare l'evento stesso di danneggiamento.
	Problema: se il danno venisse modificato come notifichi poi il/i target finali? Aggiungendo un metodo
		"doAfterNotifyingEverybody(gameModality)" ?
		Pesante e complesso ... ma forse necessario per gli oggetti tipo "preveni la morte sacrificando
		questo oggetto" (a.k.a.: "death-saver").
		Risulta pesante anche perchè OGNI nemico, giocatore e "pet" può subire danno, QUINDI OGNI danno dovrà
		essere passato in rassegna a TUTTI gli ascoltatori, con complessità di O(N*A), con
		N = n° danni effettuati in un ciclo e A = n° ascoltatori/osservatori .. il chè è TANTO
- - logica del mondo chiuso:
	si impediscono le MOD libere, si sa esattamente come funziona il gioco e quindi si attivano tutte le meccaniche
	A MANO
	Problema: in cose grosse, si raggiunge facilmente allo spaghetti code, ci si dimenticherà di "collegare tutto",
		diventerà impossibile seguire il flusso di chiamate (perchè c'è poca corretta-delegazione delle
		responsabilità E è tutt'altro che automatizzato
		
TOTALE:
1) Mondo chiuso per le cose più ottimizzate e critiche, che da risolvere sono un casino, tipo:
	- "death-saver"
	- damage management ( danno -> applica incrementi/decrementi e poi moltiplicatori del source -> ferisci il target ->
		target applica i +/- e moltiplicatori -> spara eventi DamageInflicted e DamageReceived o blocked, etc)
		
2) mettere come ascoltatori di eventi quelle "classi/tipologie" di oggetti che sono
	-) pochi
	-) preferibilmente di rara attivazione
	-) non critici (es: on-healing,

Insomma, fare un po' di selezione e per le cose più incasinate implementare una "patch".
Infatti gli eventi dovrebbero essere semplicemente delle azioni da fare "in seguito" all'evento,
dei trigger. Gli eventi che invece possono essere modificati, soprattutto pesantemente (come danno, cura e morte)
fino ad essere totalmente invalidati .. beh, conviene fare hard-code, magari nella GameModality stessa,
perchè sennò la complessità nel far processare un evento a tutti esplode malamente. E gli FPS calano.


















_______________________________
pre 19/03:
_______________________________


STRUTTURA GENERALE GROSSA


Ogni istanza di GameLauncher ha una istanza di GameGUI e GameController.

Quest'ultima gestisce un ControllerModel, che ne definisce lo "stato" appunto,
il sistema di Input (mouse e tastiera, gamepad, touch, frecce direzionali, etc)
e, soprattutto un insieme di GameModality
(Es:
- PvsIA, 1v1, Multi_VS_Multi, etc
- dungeons, open world, YouVsWawesOfEnemies
- chess like, usual RPG through maps, etc
)



__________________________________



In ogni GameModality:
static final long MIN_DELTA = 10L;

void runGame(){
	long start, lastDelta;
	while( isAlive() ){
		lastDelta = MIN_DELTA;
		while(isPlaying()){
			start = System.currentTimeMillis();
			doOnEachCycle(lastDelta);
			lastDelta = Math.min(MIN_DELTA, System.currentTimeMillis() - start );
		}
	}
}

/**Designed to be overrided*/
void doOnEachCycle(long millisecToElapse){
	// first, move everybody
	for each MovableObject mo {
		mo.move(lastDelta);
	}
	// then make everyone act
	for each ActiveObject ao {
		ao.act(lastDelta); // fai progredire QUALSIASI cosa: abilità che si ricaricano col tempo, rigenerazioni, movimento di proiettili e cose, etc
	}
	// then, perform each event
	getGameEventManager().manageAll();
}

e mettere a disposizione metodi per aggiungere ActiveObjects e non solo




--------------------------------------------------------------


ActiveObject - TimeProgressingObject - TimeEvolvingObject
interfaccia per definire un qualcosa che modifica il suo stato nel tempo, che progredisce
può definire metodi come "act", "move", etc
può far innescare eventi, come l'essersi mosso (utile per le "trappole a pressione", per controllare le collisioni tra oggetti,
ascoltatori di eventi come "ogniqualvolta entra una creatura in campo, fai XYZ", etc...)

Si consiglia di architettare la GameModality come avente un metodo del tipo "moveObject",
il quale può essere interpretato come un "teleport" (sarà quindi compito dell'oggetto stesso e
non del GameModality [o di un più generico GameObjectsInSpaceManager] tenere traccia del percorso
che sta seguendo, di far muovere passo passo l'oggetto, etc)
(magari moveObject può essere generico, del tipo:
- se non era presente, allora addObject()
- se la destinazione è "null", allora removeObject()
- altrimenti, muovilo: remove(obj, false); add(obj, false); fireEvent(ObjectMoved, obj);
[il booleano è un overload per specificare se bisogna generare un evento associato oppure no]




--------------------------------------------------------------




GameEventManager:
Ogni GameEvent, come vedremo, ha un ID.
Questo Manager ha un insieme di GameEventHandler, plausibilmente suddisi per ciascun GameEvent.
Ciascuna suddivisione, qualora il GameEventManager implementasse effettivamente la suddivisione,
potrebbe essere una coda di priorità:
- "n > 0": alta priorità: esempio, come la "bambola Voodoo" del gioco Castlevenia, "se stai per morire,
allora mi distruggo io e tu rinasci/sopravvivi".
- "h == 0": "importante ma non troppo". Esempio: "se muori tu, io, tua fatina spirituale, muoio con te" o
"questo buff/malus dura fino alla morte"
- "h < 0": low-priority
Questo manager dovrebbe gestire ogni singolo evento come se avvenissero in contemporanea

GameEvent:
interface ObjectWIthID {
	public Integer getID();
}
interface GameEvent extends ObjectWIthID{
	// public String getName(); //needed?
}
enum ExmapleGE implements GameEvent{
	Moved, Destroyed, Spawned, DamageTaken, DamageInflicted, HealReceived, HealGained, PickedUpMoney, PickedUpObject;
	public Integer getID(){
		return ordinal();
	}
}


Per gestire la distruzione, si potrebbe definire un
interface DestructibleObject{
	public boolean isDestroyed();
	public boolean shouldBeDestroyed(); // semplice flag o cosa computata, per esempio verificando se vita<=0
	public void notifyDestruction(GameEventManager gem);
}
così da semplificare ed automatizzarne la gestione.
L'evento "EventObjDestroyed" potrebbe sia avere una referenza all'oggetto che dovrebbe
essere distrutto sia qualche flag del tipo "distructionAvoided, distructionUnavoidable", impostato da qualche handler particolare.
