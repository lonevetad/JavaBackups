TODO:
aggiunto nel 03/05/2020
1) due abilità:
- - "Shielding the Temple": "perdi prima il mana, poi la vita"
	ossia è unGEventObserver che, come riceve danno, fa scalare sia l'ammontare del danno sia il mana per il valore minimo tra i due
	dare una priorità (definita come costante statica) di almeno 1
- - "Essence insofference":
	simile a quella sopra
	int[DamageTypesTRAn.values().length] di contatori, inizializzati ad N (es: 100) e quando ricevono un danno, scalano quel contatore
		"assorbendo" il danno prima che vada a far diminuire la vita
	dare una priorità di 1 maggiore a quella sopra (usando sempre le costanti statiche)
	



TODO:
aggiunto nel 27/04/2020
aggiungere metodo per il drop randomico degli oggetti (magari in parallelo e con un GThread a parte)


TODO:
aggiunto nel 20/04/2020

Le spell devono essere un po' personalizzabili ed un po' specifiche:
-) Tutti i personaggi possono fare tutto, ma inizialmente ogni personaggio ha un insieme di spell tipiche.
-) Infatti ogni Player ha tre insiemi:
- - quelle di default, fornite dalla propria classe di appartenenza (uno skill-tree, magari)
- - - es: gli elfi spareranno molte frecce, i maghi palle di fuoco, gli ogre dei buff agli attributi d'attacco, gli umani evocano altri umani, ec
- - quello di skill apprese (tramite libri e non solo), che possono essere TUTTE le magie esistenti, inizialmente quelle di cui sopra E sbloccate
- - quello di skill attualmente equipaggiae ed utilizzabili in battaglia

Il GameController dovrà poi definire i metodi di "caricamento dei salvataggi" (oltre a quello delle mappe)
tra cui caricare un Player, col suo livello, inventario, etc. Saranno necessari dei loader apposa

Definire poi gli altri CharacterType





TODO:
aggiunto nel 03/04/2020
aggiungere "edit distance" in Comparators come STRING_COMPARATOR_EDIT_DISTANCE

e .. le statistiche delle creature variano di qualche decina:
ad ogni livello si guadagnano 10 punti, gli equipaggiamenti dovrebbero fornire vantaggi pari a guadagni di circa almeno 3-5 livelli







22/03/2020
come scrissi, l'equipaggiamento è complesso e diviso in 9 pezzi + 10 anelli + 3 collane
orecchini	|	testa	|	mantello
mani		|	busto	|	braccia
piedi		|	cintura	|	gambe(pantaloni)
arma primaria	((vuoto))	arma secondaria
originariamente al posto degli orecchini c'erano le spalle .. le incorporo in "braccia", che prima erano "avambracci"
poi una colonna per ciascuna mano, le 3 collane in colonna
aggiungere i braccialetti alle due mani? troppo incasinato, ma ci sta: con le collane si otterrebbe una colonna completa alta 5
magari al posto di "vuoto" metterci un "famiglio"
per ogni mano, se il numero di anelli supera il 2 allora si ha un progressivo malus in agilità, forza, destrezza, precisione
(tienila te una spada facendo presa con migliaia di anelli)
originariamente ciascun dito poteva tenere 2 anelli (aveva 2 slot) e gli anelli erano divisi in "slot singolo" e "doppio slot"
(un po' come le armi a due mani) e la regola di cui sopra si applicava per un numero di slot superiore a 3.
Si potrebbe implementare, con l'accortezza però che gli anelli "singoli" siano più deboli dei "doppi".
In tal caso, per calcolare il malus sopra, gli anelli doppi contano come 1.5 per tutto il dito
(mentre due anelli singoli contano come 1 ciascuno, quindi 2), perchè per essere indossati hanno delle prese ergonomiche.



19/03/2020

La logica ad eventi è avvincente, MA è sconveniente per infliggere danno alle cose che hanno una vita:
- Se si usassero gli eventi, allora bisognerebbe notificare TUTTI di ogni singolo evento di danneggiamento
	E tali oggetti dovrebbero sempre controllare che il "target" del danno non sia sè stesso (o, ancora peggio,
	controllare che sè stessi non sia inclusi nell'insieme di "targets")
- con il "danno diretto", si può da un lato semplificare, dall'altro complicare:
- - si complica perchè risulta difficile prevenire/amplificare/ridurre/redirezionare il danno, mentre con gli
	eventi risulta più facile modificare l'evento stesso di danneggiamento.
	Problema: se il danno venisse modificato come notifichi poi il/i target finali? Aggiungendo un metodo
		"doAfterNotifyingEverybody(gameModality)" ?
		Pesante e complesso ... ma forse necessario per gli oggetti tipo "preveni la morte sacrificando
		questo oggetto" (a.k.a.: "death-saver").
		Risulta pesante anche perchè OGNI nemico, giocatore e "pet" può subire danno, QUINDI OGNI danno dovrà
		essere passato in rassegna a TUTTI gli ascoltatori, con complessità di O(N*A), con
		N = n° danni effettuati in un ciclo e A = n° ascoltatori/osservatori .. il chè è TANTO
- - logica del mondo chiuso:
	si impediscono le MOD libere, si sa esattamente come funziona il gioco e quindi si attivano tutte le meccaniche
	A MANO
	Problema: in cose grosse, si raggiunge facilmente allo spaghetti code, ci si dimenticherà di "collegare tutto",
		diventerà impossibile seguire il flusso di chiamate (perchè c'è poca corretta-delegazione delle
		responsabilità E è tutt'altro che automatizzato
		
TOTALE:
1) Mondo chiuso per le cose più ottimizzate e critiche, che da risolvere sono un casino, tipo:
	- "death-saver"
	- damage management ( danno -> applica incrementi/decrementi e poi moltiplicatori del source -> ferisci il target ->
		target applica i +/- e moltiplicatori -> spara eventi DamageInflicted e DamageReceived o blocked, etc)
		
2) mettere come ascoltatori di eventi quelle "classi/tipologie" di oggetti che sono
	-) pochi
	-) preferibilmente di rara attivazione
	-) non critici (es: on-healing,

Insomma, fare un po' di selezione e per le cose più incasinate implementare una "patch".
Infatti gli eventi dovrebbero essere semplicemente delle azioni da fare "in seguito" all'evento,
dei trigger. Gli eventi che invece possono essere modificati, soprattutto pesantemente (come danno, cura e morte)
fino ad essere totalmente invalidati .. beh, conviene fare hard-code, magari nella GameModality stessa,
perchè sennò la complessità nel far processare un evento a tutti esplode malamente. E gli FPS calano.


















_______________________________
pre 19/03:
_______________________________


STRUTTURA GENERALE GROSSA


Ogni istanza di GameLauncher ha una istanza di GameGUI e GameController.

Quest'ultima gestisce un ControllerModel, che ne definisce lo "stato" appunto,
il sistema di Input (mouse e tastiera, gamepad, touch, frecce direzionali, etc)
e, soprattutto un insieme di GameModality
(Es:
- PvsIA, 1v1, Multi_VS_Multi, etc
- dungeons, open world, YouVsWawesOfEnemies
- chess like, usual RPG through maps, etc
)



__________________________________



L'evento "EventObjDestroyed" potrebbe sia avere una referenza all'oggetto che dovrebbe
essere distrutto sia qualche flag del tipo "distructionAvoided, distructionUnavoidable", impostato da qualche handler particolare.
